# SQL 99 连接查询

>   语法
>
>   ```sql
>   SELECT
>   	查询列表...
>   FROM
>   	表1 AS 别名 连接类型
>   		JOIN 表2 AS 别名 
>   	ON 连接条件
>   WHERE
>   	筛选条件
>   GROUP BY
>   	分组列表
>   HAVING
>   	分组后筛选
>   ORDER BY
>   	排序;
>   ```
>
>   ### 连接类型
>
>   	* 内连接 INNER
>   	* 左外连接 LETF OUTER
>   	* 右外连接 RIGHT OUTER
>   	* 全外连接 FULL OUTER ***MySQL不支持***
>   	* 交叉连接  CROSS

## 内连接

>   语法:
>
>   ```sql
>   SELECT
>   	字段
>   FROM
>   	表1 AS 别名
>   		INNER JOIN 表2 AS 别名
>   			ON 连接条件
>   ```
>
>   分为等值连接,非等值连接,自连接
>
>   *   同样可以添加,筛选,分组,排序
>   *   筛选条件放在 where , 连接条件放在 on ,提高可读性

### 等值连接

>   *   和sql92的等值连接效果一样,都是查询多表交集部分
>
>   ```text
>   连接是有一定顺序的
>   		连接条件之间,必须能够 "条件串联"
>   			如: a.a_id = b.b_id | b.b_id = c.c_id
>   				不能进行跨区连接
>   ```
>
>   *   可添加筛选条件
>
>   ```sql
>   -- 查询名字中包含 e 的员工名和工种名
>   /*
>   添加筛选条件
>   */
>   SELECT
>   	e.last_name,
>   	j.job_title
>   FROM
>   	employees AS e
>   		INNER JOIN jobs AS j
>   			ON e.job_id = j.job_id
>   WHERE
>   	e.last_name LIKE '%e%';
>   ```
>
>   *   可添加分组
>
>   ```sql
>   -- 查询部门个数 > 3 的城市名和部门个数
>   /*
>   添加分组筛选
>   */
>   SELECT
>   	l.city,
>   	COUNT(*) AS 部门个数
>   FROM
>   	departments AS d
>   		INNER JOIN locations AS l
>   			ON d.location_id = l.location_id
>   GROUP BY
>   	l.city
>   HAVING
>   	COUNT(*) > 3;
>   ```
>
>   *   可添加排序
>
>   ```sql
>   -- 查询哪个部门的员工个数 > 3 的部门名和员工个数,并按个数降序
>   /*
>   排序
>   */
>   SELECT
>   	COUNT(*) AS 员工个数,
>   	d.department_name AS 部门名称
>   FROM
>   	employees AS e
>   		INNER JOIN departments AS d
>   			ON e.department_id = d.department_id
>   GROUP BY
>   	d.department_name
>   HAVING
>   	COUNT(*) > 3
>   ORDER BY
>   	COUNT(*) DESC;
>   ```
>
>   *   可三表查询
>
>   ```sql
>   -- 查询员工名,部门名,工种名,并按部门名排序
>   /*
>   三标查询
>   */
>   SELECT
>   	e.last_name,
>   	j.job_title,
>   	d.department_name
>   FROM
>   	employees AS e
>   		INNER JOIN departments AS d
>   			ON e.department_id = d.department_id
>   		INNER JOIN jobs j
>   			ON e.job_id = j.job_id
>   ORDER BY
>   	d.department_id DESC;
>   ```

### 非等值连接

>   *   与sql 92 相差无几
>
>   ```sql
>   -- 查询员工对应的工资级别
>   /*
>   非等值连接
>   */
>   SELECT
>   	e.last_name,
>   	e.salary,
>   	g.grade_level
>   FROM
>   	employees AS e
>   		INNER JOIN job_grades AS g
>   			ON e.salary BETWEEN g.lowest_sal AND g.highest_sal;
>   ```
>
>   *   可进行,排序,分组,筛选
>
>   ```sql
>   -- 查询每个工资级别的员工个数 > 2 的,并且按照个数降序
>   SELECT
>   	g.grade_level,
>   	COUNT(*)
>   FROM
>   	employees AS e
>   		INNER JOIN job_grades AS g
>   			ON e.salary BETWEEN g.lowest_sal AND g.highest_sal
>   GROUP BY
>   	g.grade_level
>   HAVING
>   	COUNT(*) > 2
>   ORDER BY
>   	COUNT(*) DESC,g.grade_level ASC;
>   ```

### 自连接

>   差别不大
>
>   ```sql
>   -- 自连接
>   
>   -- 查询姓名包含字符 k 的员工的名称,上级的名称
>   SELECT
>   	e.last_name,
>   	m.last_name
>   FROM
>   	employees AS e
>   		INNER JOIN employees AS m
>   			ON e.manager_id = m.employee_id
>   WHERE
>   	e.last_name LIKE '%k%';
>   ```

## 外连接

>   查询主表中的所有,去跟从表匹配
>
>   *   条件匹配则为值,没有匹配的值则为 null
>
>   ### 关键字
>
>   *   LEFT OUTER JOIN
>   *   RIGHT OUTER JOIN
>   *   FULL OUTER JOIN  不支持
>   *   CROSS OUTER JOIN

### 左外连接,右外连接

>   *   顺序可以随意替换
>
>   ```text
>   主表和从表的区别
>   		左(右)外连接: 左(右)主
>   			如果交换顺序,可以实现同样的效果
>   		左(右)外连接查询结果 = 内连接结果 + 主表中有,从表中没有的记录
>   ```
>
>   ```sql
>   -- 查询男朋友不在女神表中的女神有哪些
>   SELECT
>   	b.`name`,
>   	bo.boyName
>   FROm
>   	beauty AS b
>   		LEFT OUTER JOIN boys AS bo
>   			ON b.boyfriend_id = bo.id
>   WHERE
>   	bo.id IS NULL;
>   ```
>
>   ```sql
>   -- 查询哪个部门没有员工
>   USE myemployees;
>   
>   -- 左外连接
>   SELECT
>   	d.*,
>   	e.employee_id
>   FROM
>   	departments AS d
>   		LEFT OUTER JOIN employees AS e
>   			ON 	e.department_id = d.department_id
>   WHERE
>   	e.employee_id IS NULL;
>   
>   -- 右外连接
>   SELECT
>   	d.department_id,
>   	d.department_name,
>   	e.employee_id
>   FROM
>   	employees AS e
>   		RIGHT OUTER JOIN departments AS d
>   			ON e.department_id = d.department_id
>   WHERE
>   	e.employee_id IS NULL;
>   ```
>
>   

### 全外连接

>   内连接的结果 + 表1无+表2有 + 表2有表1无的
>
>   **MySQL不支持**
>
>   ```sql
>   -- 全外连接
>   /*
>   MySQL 不支持
>   */
>   
>   USE girls;
>   -- 测试语法
>   SELECT
>   	b.*,
>   	bo.id
>   FROM
>   	beauty AS b
>   		FULL OUTER JOIN boys AS bo
>   			ON b.boyfriend_id = bo.id
>   WHERE
>   	bo.id IS NULL;
>   ```

## 交叉连接

>   使用关键字: **```CROSS OUTER JOIN```**
>
>   使用 SQL99 语法 实现的笛卡尔乘积
>
>   ```sql
>   -- 交叉连接
>   /*
>   使用关键字 CROSS OUTER JOIN
>   
>   	使用 99 语法实现的 笛卡尔乘积
>   */
>   
>   SELECt
>   	b.*,
>   	bo.*
>   FROM
>   	beauty AS b
>   		CROSS OUTER JOIN boys AS bo;
>   ```

## 总结

| SQL92    | SQL99                 |
| -------- | --------------------- |
| 功能更少 | 功能更多              |
| 可读性差 | 可读性强,实现语法分离 |

*   两表的交集部分,使用 INNER JOIN
*   主从表: 主表全部,与从表交集部分,使用 左(右)外连接

![image-20200422183739114](../../img/_16SQL99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/image-20200422183739114.png)

![image-20200422183812847](../../img/_16SQL99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/image-20200422183812847.png)

### 全外连接

![image-20200422183949181](../../img/_16SQL99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/image-20200422183949181.png)

![image-20200422184004965](../../img/_16SQL99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/image-20200422184004965.png)