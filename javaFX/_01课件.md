# Application

## 启动流程

1.  继承 Application,实现 start()
2.  使用一个 Stage 设置 show 显示窗口(可以使用传入的primaryStage)
3.  在 main 中调用 本类的 launch(传入 main 的 args)
4.  也可以使用: Application.launch(args) 直接启动

```java
package _01Application;

import javafx.application.Application;
import javafx.stage.Stage;

/**
 * 启动 Application 的固定流程
 *
 * @author TrueNine
 * @version 1.0
 * @time 2020/4/17
 */
public class Test0 extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    /**
     * 实现父类的方法,使用传入的 Stage 进行显示
     *
     * @param primaryStage 传入的 Stage
     * @throws Exception 来自朱磊
     */
    @Override
    public void start(Stage primaryStage) throws Exception {
        // 设置窗口名称
        primaryStage.setTitle("测试窗口");

        // 显示该窗口
        primaryStage.show();
    }
}

```

### 调用其他 继承了 Application 的类启动

1.  直接使用 Application.launch() 传入一个类对象,并且传入 main 的 args 参数

```java
Application.launch(clazz.class,args);
```



## 生命周期

1.  init 初始化.并没有继承
2.  start 开始.定义图形,显示图形
3.  stop 结束.程序结束

## show 方法的一些说明

>   在显示之前,如果没有设置宽高,其他获取宽高是不会获取到的

# 监听器的说明

>   在很多的地方都可以使用监听器,大多的套路是: 属性Property() 获取

## 大致的套路

```java
// 使用监听器监听宽高改变,动态获取宽高
stage.heightProperty().addListener(new ChangeListener<Number>() {
    @Override
    public void changed(ObservableValue<? extends Number> observable, Number oldValue, Number newValue) {
        System.out.println(newValue);
    }
});

// 监听窗口的位置
stage.xProperty().addListener(new ChangeListener<Number>() {
    @Override
    public void changed(ObservableValue<? extends Number> observable, Number oldValue, Number newValue) {
        System.out.println(newValue);
    }
});
```

# Scene

>   *   大部分组件的父类是 node,少部分是 Object 或其他
>   *   所有的 node 必须放在 场景 scene 上,scene 放置于 stage
>
>   ```mermaid
>   graph RL
>   node --> scene --> stage
>   ```
>
>   *   在根节点上的 Node,会被约束大小,为Stage大小,一般放置布局类

# Group

>   group 属于放置节点的容器

*   改变 内 组件的位置,设置组件的位置即可

```java
@Override
    public void start(Stage primaryStage) throws Exception {
        // 创建测试按钮
        Button b1 = new Button("b1");
        Button b2 = new Button("b2");
        Button b3 = new Button("b3");

        // 使按钮的位置偏移
        b3.setLayoutY(300);
        b2.setLayoutY(200);
        b1.setLayoutY(100);

        // 创建节点和容器
        Group group = new Group();
        // 为 Group 添加子组件
        group.getChildren().addAll(b1,b2,b3);
        Scene scene = new Scene(group);
        primaryStage.setScene(scene);
        primaryStage.show();
    }
```

*   设置 group 的样式,子组件也会生效

# Button

>   *   颜色16进制```后两位代表透明度```
>   *   两句setStyle() ,```后一句会覆盖前一句的属性```
>   *   ```一般设置事件就是 setOn事件,然后获取监听器```

# 文本框

>   *   TextField 与 PasswordField 基本一致
>   *   Label 只是用于显示文本

# AnchorPane

>   group 只是一个容器,用于捆绑各种组件/包括容器

# 	HBox & VBox

>   横版或者竖版平铺布局

![image-20200419013420603](../img/_01%E8%AF%BE%E4%BB%B6/image-20200419013420603.png)

# BorderPane 五方布局

>   像代码IDE一样的布局方式

![image-20200419013618942](../img/_01%E8%AF%BE%E4%BB%B6/image-20200419013618942.png)

## 一些特性

>   1.  如果设置内边距,则会露出底色
>   2.  如果四周没有高宽,或者为空,则中间布局占据所有
>   3.  如果没有给四周的布局设置宽高,或者为空,则中间布局占据所有
>   4.  不要通过 ```getChildren``` 获取子组件,然后设置子组件

# 流式布局 FlowPane

>   水平排列,并在窗口缩放时,向下折叠
>
>   ![image-20200419020525761](../img/_01%E8%AF%BE%E4%BB%B6/image-20200419020525761.png)
>
>   ![image-20200419020539309](../img/_01%E8%AF%BE%E4%BB%B6/image-20200419020539309.png)
>
>   *   同样可以设置对齐方式
>   *   会跟随别的子组件,进行排列

# 网格布局 GridPane

>   类似于 表格的布局方式
>
>   ![image-20200419134645167](../img/_01%E8%AF%BE%E4%BB%B6/image-20200419134645167.png)

## 一些操作方法

>   .add(Node,index,index)为指定的行,列添加节点
>
>   setHgap() 设置行间距
>
>   setVgap() 设置列间距 
>
>   同样可以设置对齐方式

# 栈布局 StackPane

>   类似于栈,在最上面的布局可以覆盖下面的布局

## 一些点

1.  在获取列表的时候,可以通过```.forEach()```,来遍历
2.  可以移出列表列表,然后返回列表,达到翻页的效果

# TextFlow 文本流式布局

>   向布局内 添加 Text 文本

## Text

间接继承 自 Node,一个处理,显示文本的类 ?,也可以设置样式,字体大小之类

## 其他的点

TextFlow 内,同样可以添加别的节点,但不常这么干

#  瓦片布局 TilePane

>   类似于 Flow 布局
>
>   **于流式布局不同的是,所有组件会跟随上一个组件,不管是内外边距,统一跟随**
>
>   ![image-20200419155252650](../img/_01%E8%AF%BE%E4%BB%B6/image-20200419155252650.png)

# 对话框布局 DialLogPane

>   常用的对话框,其实也没什么乱用,布局不能设置
>
>   ![image-20200419165744105](../img/_01%E8%AF%BE%E4%BB%B6/image-20200419165744105.png)

# 超链接Hyperlink

>   点击此组件会触发 ActionEvent 事件,类似于 h5 的 a href
>
>   ![image-20200420164947872](../img/_01%E8%AF%BE%E4%BB%B6/image-20200420164947872.png)
>
>   同时也可以存放多个组件,但触发的事件 是一致的
>
>   Hyperlink(String) 构造器,传入一个 URL

| 方法      | 传参   | 返回 | 注释                |
| --------- | ------ | ---- | ------------------- |
| Hyperlink | String |      | 构造器,传入一个 URL |

# 菜单栏 MenuBar,Menu,MenuItem

>   MenuBar,Menu,MenuItem
>
>   *   MenuBar: 包容菜单栏的横条
>   *   Menu: 菜单栏内的选项
>   *   MenuItem: 菜单栏打开的的物品
>
>   ![image-20200420180842890](../img/_01%E8%AF%BE%E4%BB%B6/image-20200420180842890.png)
>
>   ```mermaid
>   graph TD
>   	MenuBar --> Menu --> MenuItem
>   ```
>
>   *   MenuBar 菜单栏,Menu 菜单横条,MenuItem 菜单竖条
>   *   MenuItem 可以包含 Menu
>   *   Menu,MenuItem 内可以存放其他组件,例如存放图片
>   *   Menu,MenuItem 并不是继承Node,而是直接继承 Object

##  分隔符 SeparatorMenuItem

>   直接当成 MenuItem 使用,用于分割
>
>   ![image-20200421004908770](../img/_01%E8%AF%BE%E4%BB%B6/image-20200421004908770.png)

## 单选/多选项 ToggleGroup

>   *   ToggleGroup : 单选按钮管理组,不能添加到 Menu
>   *   RadioMenuItem: 单选按钮
>   *   CheckMenuItem: 多选按钮

 ## 自定义菜单 CustomMenuItem

>   继承自 Item ,所以直接可以当做 Item 使用

## 折叠多选框 menuButton

>   操作与 Menu 差不多,使用 getItems() 添加内容
>
>   ![image-20200421020108334](../img/_01%E8%AF%BE%E4%BB%B6/image-20200421020108334.png)

## 按钮折叠镖旗 SplitMenuButton

>   与 menuButton 相差无几,只不过有一个按钮,可以点击
>
>   ![image-20200421021138014](../img/_01%E8%AF%BE%E4%BB%B6/image-20200421021138014.png)
>
>   可以给按钮设置单机事件

# 右键菜单 ContextMenu

>   与 Menu 操作无太多差别,在右键时触发
>
>   ![image-20200421021754655](../img/_01%E8%AF%BE%E4%BB%B6/image-20200421021754655.png)

## 右键事件 setOnContextMenuRequested

>   在 Node 带来的,可以设置点击后的事件

# 折叠菜单 TitledPane,折叠组 Accordion

>   可折叠展开的菜单,也可同时放到一个组内
>
>   ![image-20200421142509337](../img/_01%E8%AF%BE%E4%BB%B6/image-20200421142509337.png)
>
>   *   不建议设置 TitledPane 的最大最小宽高,普通宽高,否则会引起不同的异常
>   *   折叠监听,折叠时不会传递值,为 null,当心 空指针异常
>
>   *   在同一个折叠组 内的 折叠菜单,只能同时展开一个

# 切换窗口 TabPane,Tab

>   如同 idea 的编辑器代码页,每个按钮都有一个窗口
>
>   ![image-20200421142610479](../img/_01%E8%AF%BE%E4%BB%B6/image-20200421142610479.png)
>
>   *   setSide 一定要放在 show 前,否则图片会出现一些问题

# 单多选,RadioButton,单,多选 CheckBox

>   可使用单选组进行包括 ToggleGroup

# 文本域 TextArea

>   用于输入一大截文本
>
>   ![image-20200422161317293](../img/_01%E8%AF%BE%E4%BB%B6/image-20200422161317293.png)

# 按钮组 ButtonBar

>   将按钮包括起来的一个组?

# 选择俩表 ChoiceBox

>   ![image-20200428175950396](../img/_01%E8%AF%BE%E4%BB%B6/image-20200428175950396.png)
>
>   